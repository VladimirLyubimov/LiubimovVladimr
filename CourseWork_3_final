#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <locale.h>
#include <ctype.h>
#define LEN 10

struct MySentence{
    wchar_t* buf;
    int num;
    int third_len;
};

typedef struct MySentence sentence;

struct MyText{
	sentence* buf;
	int size;
	int i;
};

typedef struct MyText mytext;

wchar_t* InputSentence(){
	int size = LEN;
	int i = 0;
	wchar_t* sent = malloc(size * sizeof(wchar_t));
	wchar_t ch;
    
	do{
		ch = fgetwc(stdin);
            sent[i] = ch;
            i++;
		if(i == size - 4){
			size = size + LEN;
			sent = realloc(sent, size * sizeof(wchar_t));
		};
	}while (!wcschr(L".\n", ch));
    sent[i] = '\0';
	
    return sent;
};

mytext InputText(){
	int size = LEN;
	int i = 0;
        sentence* content = malloc(size * sizeof(sentence));
     	while(1){
        content[i].third_len = 0;
        wchar_t *cp = InputSentence();
         if(wcschr(L"\n", cp[wcslen(cp) - 1])){
			break;
		}
         else{
			content[i].buf = cp;
			i++;
            content[i-1].num = i;
			if(i == size - 2){
				size = size + LEN;
				content = realloc(content, size * sizeof(sentence));
			};
		};
     };

	struct MyText text;
	text.buf = content;
	text.size = size;
	text.i = i;    
    
	return text;	
};

void PrintSentence(sentence sent){
    wprintf(L"%ls", sent.buf);    
};

void PrintText(mytext text){
    for(int i = 0; i < text.i; i++)
        PrintSentence(text.buf[i]);
    wprintf(L"\n");
};

mytext Shift(mytext text, int start){
    int i = start;
    while (i < (text.i - 1)){
        text.buf[i] = text.buf[i+1];
        text.buf[i].num = text.buf[i].num - 1;
        i = i + 1;
    };
    text.i = text.i - 1;
    
    return text;
}

int SentCompare(sentence samplesent, sentence sent){
    int bol = 0;
    wchar_t* s1;
    wchar_t* s2;
    s1 = malloc((wcslen(samplesent.buf) + 1) * sizeof(wchar_t));
    s2 = malloc((wcslen(sent.buf) + 1) * sizeof(wchar_t));
    wcscpy(s1, samplesent.buf);
    wcscpy(s2, sent.buf);
    
    for(int i = 0; i < wcslen(s1); i++){
        s1[i] = tolower(s1[i]);
    }
    for(int i = 0; i < wcslen(s2); i++){
        s2[i] = tolower(s2[i]);
    }
    
    bol = wcscmp(s1, s2);
    
    free(s1);
    free(s2);
    
    return bol;
};

mytext ExcludeSentence(mytext text){
    int i = 0;
    int j = 1;
    while (i < text.i - 1){
            while(j < text.i){
            if (SentCompare(text.buf[i], text.buf[j]) == 0){
                free(text.buf[j].buf);
                text = Shift(text, j);
                j = j - 1;
            }
            j++;
            }
            i = i + 1;
            j = i + 1;
    }
    return text;
}

void MyFree(mytext text){
    for(int i = 0; i < text.i; i++){
        free(text.buf[i].buf);
    }
    free(text.buf);
};

wchar_t* FindWord(int number, sentence sent){
    wchar_t* word;
    wchar_t* st;
    wchar_t* buf;
    
    st = malloc((wcslen(sent.buf) + 1) * sizeof(wchar_t));
    wcscpy(st, sent.buf);
    
    word = wcstok(st, L"!., ", &buf);
    int i = 1;
    
    while ((i < number)){
        word = wcstok(NULL, L"!., ", &buf);
        i++;
    }
    
    return word;
};

sentence SentShift(sentence sent, int shift, int start){
    int i = start;
    wchar_t* st;
    if (shift >= 0)
        while (i < wcslen(sent.buf)){
            sent.buf[i] = sent.buf[i+shift];
            i = i + 1;
        }
    else{
        st = malloc((wcslen(sent.buf) + 2 - shift) * sizeof(wchar_t));
        wcscpy(st, sent.buf);
        i = wcslen(sent.buf) + 1;
        free(sent.buf);
        while (i >= start){
            st[i-shift] = st[i];
            i = i - 1;
        }
        sent.buf = st;
    }    
    return sent;
};

mytext ShiftWords(mytext text){
    wchar_t* w1;
    wchar_t* w2;
    
    for(int i = 1; i < text.i; i++){
        w1 = FindWord(1, text.buf[i]);
        w2 = FindWord(2, text.buf[i-1]);
        text.buf[i] = SentShift(text.buf[i], wcslen(w1) - wcslen(w2), 1);
        for(int j = 0; j < wcslen(w2); j++)
            text.buf[i].buf[j+1] = w2[j];
    }
    w1 = FindWord(1, text.buf[0]);
    w2 = FindWord(2, text.buf[text.i-1]);
    text.buf[0] = SentShift(text.buf[0], wcslen(w1) - wcslen(w2), 1);
    for(int j = 0; j < wcslen(w2); j++)
        text.buf[0].buf[j+1] = w2[j];
    
    return text;
};

mytext DeleteSameSymbols(mytext text){
    for(int i = 0; i < text.i; i++){
        for(int j = 0; j < wcslen(text.buf[i].buf); j++){
            if (text.buf[i].buf[j] == text.buf[i].buf[j+1]){
                text.buf[i] = SentShift(text.buf[i], 1, j);
                j = j - 1;
            }
        }
    }
    return text;
};

int FindThirdWordLen(sentence sent){
    int len;
    wchar_t* word;
    word = FindWord(3, sent);
    if(word == NULL)
        len = 0;
    else
        len = wcslen(word);
    return len;
};

int* MakeThirdLenTable(mytext text){
    int* lenarr;
    lenarr = malloc(text.i * sizeof(int));
    for(int i = 0; i < text.i; i++){
        lenarr[i] = FindThirdWordLen(text.buf[i]);
        text.buf[i].third_len = lenarr[i];
    }
    return lenarr;
};

int compare(const void * val1, const void * val2){
    return ( *(int*)val1 - *(int*)val2 );
};

int* SortThirdLen(int* lenarr, mytext text){
    qsort(lenarr, text.i, sizeof(int), compare);    
    return lenarr;
};

mytext SortText(mytext text){
    int* arr;
    int shift = 0;
    sentence sent[text.i];
    arr = MakeThirdLenTable(text);
    arr = SortThirdLen(arr, text);
    for(int i = 0; i < text.i; i++){
        for(int j = 0; j < text.i; j++){
            if(text.buf[i].third_len == arr[j]){
                arr[j] = -1;
                sent[j] = text.buf[i];
                break;
            }
        }    
    }
    for(int i = 0; i < text.i; i++)
        text.buf[i] = sent[i];
    return text;
};

int CheckWord(wchar_t* word){
    int bol = 0;
    if (!wcschr(L"0123456789", word[0]) && !wcschr(L"0123456789", word[wcslen(word)-1]) && wcspbrk(word, L"0123456789")){
        bol = 1;
    }
    return bol;
};

int* FindNumInWord(mytext text){
    wchar_t* word;
    int* arr;
    arr = calloc(text.i + 1, sizeof(int));
    int k = 0;
    int j = 0;
    for(int i = 0; i < text.i; i++){
        word = FindWord(k, text.buf[i]);        
        while(word != NULL){
            if (CheckWord(word) == 1){
                arr[j+1] = i;
                j = j + 1;
                break;
            }
            k = k + 1; 
            word = FindWord(k, text.buf[i]);
        }
        k = 0;
    }
    arr[0] = j;
    
    return arr;
};

void PrintNumWords(mytext text, int* arr){
    wchar_t* buf;
    wchar_t* word;
    wchar_t* sent;
    for(int i = 1; i <= arr[0]; i++){
        sent = malloc((wcslen(text.buf[arr[i]].buf) + 1) * sizeof(wchar_t));
        wcscpy(sent, text.buf[arr[i]].buf);
        word = wcstok(sent, L"!. ", &buf);        
        while(word != NULL){
            if (CheckWord(word) == 1){
                wprintf(L"%ls ", word, "\033[0;32m", "\033[0m");
            }
            else
                wprintf(L"%ls ", word);
            word = wcstok(NULL, L" ", &buf);
        } 
        free(sent);
    }
};

void PrintTip(){
    wprintf(L"\nДля получения информации о программе нажмите <H>.\nДля выхода из программы нажмите <E>.\nДля замены первого слова в каждом предложении на втрое слово из преыдущего нажмите <1>.\nДля сортировки предложений по длине третьего слова нажмите <2>.\nДля вывода на экран предложений со словами вида *число* нажмите <3>.\nДля замены всех подряд идущих символов на один такой символ в каждом слове каждого предложения нажмите <4>.\n");
}; 

int main(){
    setlocale(LC_ALL,"");
    
    mytext ttext;
    int* a;
    wchar_t key;
    
    ttext = InputText();
    ttext.buf[0] = SentShift(ttext.buf[0], -1, 0);
    ttext.buf[0].buf[0] = ' ';
    ttext = ExcludeSentence(ttext);
    
    wprintf(L"Текст введён и повторяющиеся предложения удалены.\n");
    PrintTip();
    PrintText(ttext);
    wprintf(L"\n");
    
    while(1){
        key = getwchar();
        if (key == 'h'){
            wprintf(L"\nText processor version 1.0. Created by Vladimir Lyubimov, Russia, Saint-Petersburg, ETU LETI, 2019. All rights reserved.\n");
        }
        else{
            if (key == 'e'){
                wprintf(L"\nYou have commanded to stop the execucting of the programm.\n");
                MyFree(ttext);
                break;
            }
            else{
                if (key == '1'){
                    ttext = ShiftWords(ttext);
                    PrintText(ttext);
                }
                else{
                    if(key == '2'){
                        ttext = SortText(ttext);
                        PrintText(ttext);
                    } 
                    else{
                        if(key == '3'){
                            a = FindNumInWord(ttext);
                            PrintNumWords(ttext, a);
                        }
                        else{
                            if(key == '4'){
                                ttext = DeleteSameSymbols(ttext);
                                PrintText(ttext);    
                            }
                            else
                                wprintf(L"\nIncorrect command! Please read a tip and repeat your request.\n");
                        }
                    }
                }
            }
        }
        PrintTip();
    }
    
    return 0;
};
